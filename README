NAME
    Graphics::HotMap -- generate thermographic images.

SYNOPSIS
       use Graphics::HotMap;

       # Create a new HotMap
       my $hotMap = Graphics::HotMap->new(
             minValue => 1,
             maxValue => 50, 
             );  

       # Define scale
       $hotMap->scale(20);

       # Show legend
       $hotMap->legend(1);

       # Show CrossMarks and values
       $hotMap->crossMark(1,1);

       # Define a new size
       $hotMap->mapSize({ sizeX => 15, sizeY => 15 }); 

       # Add time
       $hotMap->addHorodatage(time, 15, 30);

       # Add layer
       $hotMap->addLayer({ layerName => '10_back', visibility => 1, sliceColor => 1 }); 

       # Add a zone
       $hotMap->addZone({
             zoneName => 'AllMap',
             layerName => '10_back',
             coordonates => [0,0,14,14],
             border => 1,
             }); 
       # And add some points
       $hotMap->addPoint({ layerName => '10_back', x => 2, y => 2,  value => 15 });
       $hotMap->addPoint({ layerName => '10_back', x => 1, y => 6,  value => 5  });
       $hotMap->addPoint({ layerName => '10_back', x => 9, y => 13, value => 25 });
       $hotMap->addLayer({ layerName => '20_inner' });

       # Add a zone
       $hotMap->addZone({
             zoneName => 'innerZone',
             layerName => '20_inner',
             coordonates => [4,0,9,6],
             border => 1,
             text => 'Inner Zone',
             });

       # And some points
       $hotMap->addPoint({ layerName => '20_inner', x => 5, y => 1, value => 1 });
       $hotMap->addPoint({ layerName => '20_inner', x => 6, y => 5, value => 9 });

       # You can also prepare conf as a Hash, ...
       my %other = (
          layers => {
             '30_anotherLayer' => {
                visibility  => 0,
                sliceColors => 1,
             },
             '40_anotherLayer' => {
                visibility  => 0,
                sliceColors => 0,
             },
          },
          zones => {
             anotherZone => {
                layerName => '30_anotherLayer',
                coordonates => [7,4,10,9],
                border => 1,
                text => 'other layer',
                textSize => 8,
                textColor => 'magenta',
             },
             zoneA => {
                layerName => '40_anotherLayer',
                coordonates => [0,10,1,12],
                border => 1,
                text => 'black',
                textSize => 8,
                textColor => 'white',
             },
             zoneB => {
                layerName => '40_anotherLayer',
                coordonates => [1,10,2,12],
                border => 1,
                text => 'blue',
                textSize => 8,
                textColor => 'white',
             },
             zoneC => {
                layerName => '40_anotherLayer',
                coordonates => [2,10,3,12],
                border => 1,
                text => 'green',
                textSize => 8,
                textColor => 'white',
             },
             zoneD => {
                layerName => '40_anotherLayer',
                coordonates => [3,10,4,12],
                border => 1,
                text => 'cyan',
                textSize => 8,
                textColor => 'white',
             },
          },
          points => {
             '30_anotherLayer' => [
                [8,5,46],
                [10,9,22],
             ],
             '10_back' => [
                [13,1,50],
             ],
             '40_anotherLayer' => [
                [0,10,1],
                [1,10,2],
                [2,10,3],
                [3,10,4],
             ],
          },
       );

       # ..., and import/add it
       $hotMap->addConfs(\%other);

       # Run the interpolation and generate and image
       $hotMap->genImage;

       # Save the image a a PNG file
       $hotMap->genImagePng('MyTest.png');

       # print the text representation of the map
       print $hotMap->toString('floor') if $hotMap->scale < 3;

DESCRIPTION
    Generate thermographic images from a few know points. Others values are
    interpolated. Graphics::HotMap use PDL to work on matrix. PDL can
    compute very very large matrix in a few seconds.

    See <http://kumy.org/HotMap/HotMap.png>

  FUNCTIONS
    new(<HASH>)
        Construct and return a new HotMap Object;

           Graphics::HotMap->new(
              outfileGif        => <File path>, # file to write GIF
              outfilePng        => <File path>, # file to write PNG
              legend            => [0|1],       # activate lengend
              legendNbGrad      => <number>,    # Number a graduation
              cross             => <bool>,      # activate crossing of known values
              crossValues       => <bool>,      # activate values printing whith cross
              minValue          => <number>,    # minimum value
              maxValue          => <number>,    # maximum value
              font              => <path to font file>,
              fontSize          => <number>,    # font size
              scale             => <number>,    # scale values and coordonates
              sizeX             => <number>,    # X size
              sizeY             => <number>,    # Y size
           );

           my $hotMap = Graphics::HotMap->new(
              sizeX    => 10, 
              sizeY    => 10, 
              minValue => 1,
              maxvalue => 50,
           );

    initKnownPoints()
        Reset all know points.

    mapSize(<HASH>)
        Set or Return mapSize

           $hotMap->mapSize({sizeX => 15, sizeY => 15}); # Set map size
           @size = $hotMap->mapSize; # Return the actual map size

    scale(<SCALAR>)
        Set or Return current scale factor.

           $hotMap->scale(2);
           $scale = hotMap->scale;

    addLayer(<HASH>)
        Define a new Layer to store values.

        Layers are parsed by alphabetical order.

        * visibility (default: 1) : allow crossMarks to be displayed for
        this layer.

        * sliceColor (default: 1) : colors are looked up in the gradient. If
        set to 0, values between 0 to 16 are fixed colors (LUT).

           $hotMap->addLayer({ layerName => 'Layer1' });
           $hotMap->addLayer({ layerName => 'Layer2', visibility => 1, sliceColor => 1 });

    addZone(<HASH>)
        Define a new zone to interpolate over a layer.

           $hotMap->addZone({
              zoneName => 'AllMap',      # zone name
              layerName => 'Layer1',     # layer from which zone belongs
              coordonates => [0,0,9,9],  # coordonates [startX, startY, endX, endY]
              border => 1,               # border color (LUT) or undef for none
              text => "your text",       # 
              textSize => 10,            # 
              textColor => 'red',        # 
              noScale = 0,               # if true, coordonates will not be auto-scaled
           });

    addPoint(<HASH>)
        Add a know point to a zone. Zone should first be declared with
        addZone.

           $hotMap->addPoint({
              layerName   => 'AllMap',
              x           => 7,
              y           => 8,
              value       => 25,
              noScale     => 0,
           });

    addHorodatage($timestamp, $x, $y)
        Timestamp on the image.

           $hotMap->addHorodatage(time, 10, 10);
           $hotMap->addHorodatage(1269122338, 10, 10);

    addText(<HASH>)
        Add text on the image.

           $hotMap->addText({
              text        => "your text",
              x           => $x,
              y           => $y,
              font        => <path to font file>
              pointsize   => 10,
              fill        => 'black',
              align       => '[left|center|right],
           });

    addConfs(<HASH>)
        Add Layers/Zones/Point from a hash config.

           my %other = (
              layers => {
                 '30_anotherLayer' => {
                    visibility  => 0,
                    sliceColors => 1,
                 },
              },
              zones => {
                 anotherZone => {
                    layerName => '30_anotherLayer',
                    coordonates => [7,4,10,9],
                    border => 1,
                    text => 'other layer',
                    textSize => 8,
                    textColor => 'magenta',
                 },
              },
              points => {
                 '30_anotherLayer' => [
                    [8,5,46],
                    [10,9,22],
                 ],
              },
           );
   
           $hotMap->addConfs(\%other);

    getPoint()
        Return a point value at coordonate x/y. Without a zone name, it
        returns a point from the interpolated table. With zone name, it
        returns a point from that zone.

           $hotMap->getPoint(6, 2, 'Zone1')
           $hotMap->getPoint(6, 2)

    fusionLayers()
        Fusion the second layer to the first one.

           $hotMap->fusionLayers('AllMap', 'Zone1');

    getLayer()
        Return all values from a layer.

           my $piddleVal = $hotMap->getLayer('AllMap');

    setLayer()
        Define all values from a layer.

           $hotMap->setLayer('AllMap', $piddleVal);

    toString()
        Convert the interpolated table to text. The parameter 'floor' can be
        added to return rounded values.

           print $hotMap->toString('floor');
   
           [
            [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1]
            [ 1 14 14 14 14 13 13 13 13 13 14 14 14 15  1]
            [ 1 14 15 14 13 13 13 13 13 13 14 14 15 15  1]
            [ 1 13 14 13 13 12 12 13 13 14 14 15 15 15  1]
            [ 1  9 10 11 11 12 12 13 13 14 15 15 16 16  1]
            [ 1  6  7  8 10 11 12 13 14 15 15 16 16 17  1]
            [ 1  5  5  7  9 11 12 13 14 15 16 17 17 17  1]
            [ 1  5  6  7  9 11 13 14 16 17 17 18 18 18  1]
            [ 1  6  7  8 10 12 14 16 17 18 19 19 19 19  1]
            [ 1  8  8 10 11 14 16 18 19 20 21 21 20 20  1]
            [ 1  9 10 11 13 16 18 20 21 22 22 22 21 21  1]
            [ 1 11 12 13 15 17 20 22 23 23 23 23 22 22  1]
            [ 1 12 13 15 17 19 21 23 24 24 24 24 23 22  1]
            [ 1 13 15 16 18 20 22 23 24 25 24 24 23 22  1]
            [ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1]
           ]

    legend()
        Set or Return legend status. When enabled, the legend gradient will
        be drawn on the image.

    crossMark()
        Set or Return cross marks status. When enabled, a cross will be
        drawn on the image where points have been defined.

        Set the gradient.

        Parameter must be an array of RGB array.

        See Math::Gradient::multi_array_gradient()

    genImage()
        Calculate the interpolation of all Zones.

        This function will write image to disk.

    genImagePng()
        Write a PNG image from the interpolated table.

           $hotMap->genImagePng('<path_to_png'>);

    genImageGif()
        Add a GIF image to the annimation from the interpolated table.

           $hotMap->genImageGif('<path_to_gif'>);

SEE ALSO
    PDL

    Math::Gradient

AUTHOR
    Mathieu Alorent (cpan@kumy.net)

